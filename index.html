<!doctype html>
<html>
<head>
<meta charset="utf-8">
<!-- include CAF & your own player library -->
<style type="text/css">
html, body, video { /* fit the player to the screen's dimensions */
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    color: white;
}
.loader { /* primitive text-based loading indicator */
    position: absolute;
    inset: 0;
    justify-content: center;
    align-content: center;
    font-size: 50px;
}
</style>
</head>
<body>
<div class="loader">Loading...</div>
<video controls></video>
<script type="application/javascript">
const context = cast.framework.CastReceiverContext.getInstance();
const playerManager = context.getPlayerManager();
const videoElement = document.querySelector('video');
let hls; // static instance of hls.js (destroyed when playing another media is requested)

// For brevity, all the code handling the `.loader` element is stripped.
const setStatus = ({ isLoading, error }) => {
    const loader = document.querySelector('.loader');
    if (isLoading) {
        loader.style.display = 'flex';
    } else {
        loader.style.display = 'none';
    }
    if (error) {
        loader.textContent = error;
    }
};

// When the video element has successfully loaded data, hide the loader.
videoElement.addEventListener('loadeddata', () => setStatus({ isLoading: false }));

// Intercept loading requests.
playerManager.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, event => {
    if (!event.media.entity) // legacy
        event.media.entity = event.media.contentId;
    // event.media.entity contains the user-defined URL to load.

    const reqId = event.requestId, sender = event.senderId;
    setStatus({ isLoading: true });

    // Return a promise 
    return new Promise((resolve, reject) => {
        // Destroy any pre-existing player.
        if (hls) {
            hls.destroy();
            hls = null;
        }

        const mediaUrl = event.media.entity;

        if (mediaUrl.endsWith('.m3u8')) {
            // Handle HLS stream with hls.js
            hls = new Hls();

            // Attach Referer header for vidmoly.to
            hls.config.xhrSetup = function(xhr, url) {
                xhr.setRequestHeader('Referer', 'https://vidmoly.to');
            };

            hls.attachMedia(videoElement);
            hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                hls.loadSource(mediaUrl);
                videoElement.play();
            });

            hls.on(Hls.Events.MANIFEST_PARSED, () => resolve(event));

            hls.on(Hls.Events.ERROR, (e, data) => {
                if (!data.fatal) return;
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        const error = new cast.framework.messages.ErrorData(cast.framework.messages.ErrorType.LOAD_FAILED);
                        error.reason = cast.framework.messages.ErrorReason.GENERIC_LOAD_ERROR;
                        hls.destroy();
                        setStatus({ error: 'Network error :-(' });
                        return resolve(error);
                    case Hls.ErrorTypes.MEDIA_ERROR:
                        hls.recoverMediaError();
                        break;
                    default:
                        playerManager.sendError(sender, reqId, cast.framework.messages.ErrorType.LOAD_FAILED);
                        setStatus({ error: 'Unrecoverable error' });
                        hls.destroy();
                        break;
                }
            });
        } else {
            // Handle standard MP4 stream
            videoElement.src = mediaUrl;
            videoElement.load();
            videoElement.play();
            resolve(event);
        }
    });
});

// Handle pause and play messages
const changePlaybackStatus = ({ shouldPlay }) => m => {
    videoElement[shouldPlay ? 'play' : 'pause']();
    playerManager.broadcastStatus(true);
    return m;
};

playerManager.setMessageInterceptor(cast.framework.messages.MessageType.PAUSE,
    changePlaybackStatus({ shouldPlay: false }));
playerManager.setMessageInterceptor(cast.framework.messages.MessageType.PLAY,
    changePlaybackStatus({ shouldPlay: true }));

// Start the Cast Receiver Framework
const options = new cast.framework.CastReceiverOptions();
options.skipPlayersLoad = true;
options.disableIdleTimeout = true;
options.supportedCommands = cast.framework.messages.Command.ALL_BASIC_MEDIA;
context.start(options);
</script>
</body>
</html>
